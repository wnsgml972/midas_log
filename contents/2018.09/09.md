# MIDAS LOG

## go home! [:house_with_garden:](https://github.com/wnsgml972/midas_log)

---

<br/><br/>

## 09.03

* 적응
  * help.midasit.com (네트워크 환경 구성 등등)
  * 모니터 신청, RAM 신청
  * 각종 회원가입
  * 개발환경 구성
* C++ 공부

## 09.04

* 자기소개 PPT 발표 준비
* MFC 공부

## 09.05

* MFC로 전화번호부 구현 시작

### Visual Assist

``Alt + O``
  - Header file과 Source file같은 전환~같은 전환

``Alt + G``
  - 함수의 선언과 구현부를 왔다갔다 함

``Ctrl + G``
  - 원하는 줄로 이동함

``Alt + Shift + S``
  - 심볼 찾기

`` Alt + Shift + O``
   - 파일 찾기

``Alt + M``
 - 현재 파일의 함수 찾기

``Shift + Alt + F``
 - Reference 찾기



## 09.06

* [MFC 전화번호부 완성](https://github.com/wnsgml972/MFCPhoneBook)

### 컴파일 경고는 되도록 모두 잡고 가자

* 필요 없는 컴파일 경고 없애는 방법

<pre>
#pragma warning(push)
#pragma warning(disable: 4351)
#pragma warning(pop)
</pre>

* 밑에 처럼 하면 Test 경고는 출력이 안 되고, SubTest 경고는 출력된다.

<pre>
#pragma warning(push)
#pragma warning(disable: 4351)

class Test
{
    int m_ints[10];
    double m_doubles[10];

public:
    Test()
        : m_ints() // C4351
        , m_doubles() // C4351
    {
    }
};

#pragma warning(pop)

class SubTest : public Test
{
    bool bools[10];

public:
    SubTest()
        : bools() // C4351
    {
    }
};
</pre>

### CString <-> string

<pre>
string CStringToString(CString cstr)
{
	char cpResult[200];

#pragma warning(push)
#pragma warning(disable: 4996)
	strcpy(cpResult, CT2A(cstr));
	if (cpResult == NULL)
	{
		strcpy(cpResult, "");
	}
	cpResult[strlen(cpResult) + 1] = '\0';
#pragma warning(pop)

	return cpResult;
}

CString StringToCString(string str)
{
	CString strResult;

	strResult = str.c_str();
	strResult += '\0';

	return strResult;
}
</pre>


## 09.07

* MFC 인테리어 프로그램 개발

* mday 자기소개 발표!

* 이번 주 마무리
  * OpenSource 경진대회 휴가 계획 짜기
  * 밀렸던 자료 정리
  * 김남윤 교수님께 메일?
  * 다음 주 할 일 미리 정리


---

<br/>



## 09.10

* MFC 인테리어 프로그램 개발 시작

* 먼저 설계부터 하자. MVC 생각하면서 설계하면 좀 편함

* [단일 문서 기본 틀 생성](http://ryumin13.tistory.com/entry/mfc%EB%A1%9C-%ED%88%B4%EB%A7%8C%EB%93%A4%EA%B8%B0-%EA%B8%B0%EB%B3%B8-%EB%BC%88%EB%8C%80-%EB%A7%8C%EB%93%A4%EA%B8%B0?category=388236) : 진짜 어려움... FormView가 생성이 안 되서 따로 만들어 줘야 함, 만들어진 자료 확인

* MVC 패턴에 기반한 기본 틀 완성!




## 09.11

* [MFC InteriorProgram](https://github.com/wnsgml972/MFC-InteriorProgram) : 첫 커밋,   __Controller의 싱글톤과 FileManager, Main의 define__

* MVC 패턴에 기반한 기본 틀 함수 추가, MVC에 따른 패키징!

* DrawRoom, Select 구현

* SAFE DELETE, 원하는 뷰 포인터 얻어오기

<pre>
#define SAFE_DELETE(p) { if(p) {delete p; p = NULL;} }
</pre>

<pre>

☞ 헤더파일 포함 순서.
#include "stdafx.h"
#include "Example.h"
#include "MainFrm.h"
#include "ExampleDoc.h"
#include "ExampleView.h"

== SDI의 경우 ===

[ 뷰클래스의 포인터 받기 ]
1) SDI의 경우
CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
CTempView *pView = (CTempView *)pMainFrame->GetActiveView();


[정리하자면]
어플리케이션 클래스
1) CXXXXApp *pAPP = (CXXXXApp *)AfxGetApp();

메인플레임 클래스 얻기
1) CMainFrame *pMainFrame =(CMainFrame*) AfxGetApp()->m_pMainWnd;

View클래스 얻기
1) 메인플레임 클래스를 먼저 얻음.
2) CXXXXView *pView = (CXXXXView *)pMainFrame->GetActiveView();

Document 클래스 얻기
1) 메인플레임 클래스를 먼저 얻음.
2) CXXXXDoc *pDoc = (CXXXXDoc *)pMainFrame->GetActiveDocument();

[실제 프로그램 예시]
CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();  // 프레임 윈도우 포인터 구하고...
//CInteriorProgramView* pView = (CInteriorProgramView*)pFrame->GetActiveView(); // 활성화된 뷰의 포인터 구한다.
CInteriorProgramView* pView = (CInteriorProgramView*)pFrame->m_wndSplitter.GetPane(0, 0); // 활성화된 뷰의 포인터 구한다.

pView->RedrawWindow();
</pre>




## 09.12

* MFC 환경에서 console에 log 출력하는 법

<pre>
-> 이것을 stdafx.h의 제일 위에다 넣으면 됨

#ifdef _DEBUG
#ifdef UNICODE
#pragma comment(linker, "/entry:wWinMainCRTStartup /subsystem:console")
#else
#pragma comment(linker, "/entry:WinMainCRTStartup /subsystem:console")
#endif
#endif
</pre>

__

### 소멸자 virtual, c++의 instanceof인 typeid

- c++에서 virtual을 붙여주게 되면 상속 관계에서 파생 클래스의 함수를 부르게 된다.
- 상속 관계에서 소멸자에 virtual을 붙여놓지 않는다면, 만약 업캐스팅한 객체는 해당 가리키고 있는 객체의 소멸자를 호출하지 않게된다.
그러므로 통상적으로 상속관계에 있는 클래스중 제일 상위 클래스의 소멸자에는 보통 virtual을 붙인다.

- 여기에서 하나 문제가 있다. 해당 객체의 type을 알 수 있는 c++의 typeid에서, 업캐스팅한 객체의 타입을 알고 싶었는데
가리키고 있는 객체의 타입이 아닌 자기 자신만 가리키는 결과가 나왔다. <br/>
-> 해결방법으로 상위 클래스에 소멸자를 붙여주게 되면 하위 클래스의 소멸자를 호출하여 올바르게 가리키는 객체를 참조하는 결과가 나왔다. 그러므로 typeid를 쓰려면

<pre>
1. 헤더파일 typeinfo 선언
2. 상위 클래스의 소멸자에 virtual 선언
3. typeid(m_CaShape.at(i)) == typeid(DoorShape)
다음과 같이 비교하면 된다.
</pre>


### Select  (어려움...)

1. 알고리즘

2. 기준 꼭지점을 정해야함


### Move  (핵 어려움...)

1. MouseDown 시 선택된 Shape의 기준 꼭지점과 클릭한 point와의 차이점을 구해놓는다.

2. MouseMove에서 구해놓은 차이와 현재 드래그 되는 좌표값을 더해준다!

3. 그 값은 InteriorProgramView를 넘으면 안 된다.

4. 그 외 프로그램 상 각종 예외처리

### 진행상황

__[09.12] Issue 1. 80% 해결__

1. Move 성공!
2. Update 성공!
3. HowManySeleted 성공!
4. Current Selected 성공!
5. AddShape 미완
6. DeleteShape 미완

__현재까지 각종 Error 체크 했을 시 오류 없었음!__






## 09.13

> 천천히 생각하자. 오늘은 계속 어려운 것만 해결하다보니 많이 힘들었다. <br/>
그래도 천천히 많이 생각하고, 코드를 깨끗하게 구조를 깨끗하게 하다보니 오래 생각하면 계속 방법이 나왔다. <br/>
급하게 짜지 말고 좋은 방법을 찾을 것!


__[09.13] Issue 2__

1. DrawDoor
2. MoveDoor
3. DrawWindow
4. MoveWindow
5. AddShape
6. DeleteShape

__마우스 우클릭 삭제 이벤트 구현했음__

### SetDoorWindowRange (개 핵핵핵핵 어려움)

* Door와 Window는 Room의 범위내에서 특정 크기 한정으로 그려져야한다.

* 그려지는 범위가 특정 어느 룸의 DrawRange 범위인지 찾고 거기서 각각 그려지는 방향에 맞춰서 고정할 부분을 고정하고 움직일 부분은 움직이며 그린다.

* 그 상황 속에서 선택된 룸은 그 문을 가지고 있다는 뜻으로 룸의 ShapeVector 인덱스를 기억하다가 마우스를 때면 전체 벡터에 문을 넣고, 해당 룸의 Door나 Window 벡터에도 객체를 담는다.  ```m_nRememberIndexForDoorWindowVector```

* 문과 창문의 자세한 알고리즘은 너무 기므로 생략 __SetDoorWindowRange__ 라는 ShapeHandler의 멤버함수에 있다.

* 방을 삭제할 때는 그 방이 가지고 있는 Door와 Window 벡터를 모두 삭제하고 전체 벡터 상에서도 Door와 벡터를 삭제해야한다. 즉 둘다 삭제해야 하는데, 둘다 넣고 삭제하는 것이 쉽지 않았다.

* 그룹화 삭제 알고리즘  ```DeleteSelectedShape```의 함수를 보면 코드가 있다.

<pre>
/// 그룹화 삭제 알고리즘
// 찾아서 삭제하는데! 하나 삭제하면 전체 갯수가 줄어드므로 벡터의 인덱스가 바뀜!
// 그렇기 때문에 다음 루프에서 또 삭제할 때 오류가 남
// 해결 방법으로 벡터의 맨 뒤에서부터 검색해 삭제할 것을 찾으면 됨
// 근데 창문과 문을 섞어서 만들경우 결국 생성 인덱스가 섞여버림...
// 정렬해야 됨, 정렬해서 뒤에서부터 삭제해야 됨...
// 새로운 벡터를 생성해 값을 다 넣고 정렬한다음 삭제한다.
</pre>

### 해결한 것

1. DrawDoor 해결
2. MoveDoor 미완 -> 룸의 범위를 벗어나게 하면 안 됨
3. DrawWindow 해결
4. MoveWindow 미완 -> 룸의 범위를 벗어나게 하면 안 됨
5. AddShape 해결
6. DeleteShape 해결

### 해야할 것

1. MoveDoor
2. MoveWindow
3. MoveGroup
4. Redo, Undo ( 딜리트 시 스택에 담으면 됨 )
5. Scale ( 마우스 휠 이벤트 처리기로 하기 )
6. Edit, Copy, Rotate ( 이벤트 처리기 리스너 만들어놈 )
7. User Object ( 마그네틱, 스냅 등등 )
8. Material ( 그냥 이미지 덮기 )
