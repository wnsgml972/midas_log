# MIDAS LOG

## go home! [:house_with_garden:](https://github.com/wnsgml972/midas_log)

---

<br/><br/>

## 09.03

* 적응
  * help.midasit.com (네트워크 환경 구성 등등)
  * 모니터 신청, RAM 신청
  * 각종 회원가입
  * 개발환경 구성
* C++ 공부

## 09.04

* 자기소개 PPT 발표 준비
* MFC 공부

## 09.05

* MFC로 전화번호부 구현 시작

### Visual Assist

``Alt + O``
  - Header file과 Source file같은 전환~같은 전환

``Alt + G``
  - 함수의 선언과 구현부를 왔다갔다 함

``Ctrl + G``
  - 원하는 줄로 이동함

``Alt + Shift + S``
  - 심볼 찾기

`` Alt + Shift + O``
   - 파일 찾기

``Alt + M``
 - 현재 파일의 함수 찾기

``Shift + Alt + F``
 - Reference 찾기



## 09.06

* [MFC 전화번호부 완성](https://github.com/wnsgml972/MFCPhoneBook)

### 컴파일 경고는 되도록 모두 잡고 가자

* 필요 없는 컴파일 경고 없애는 방법

<pre>
#pragma warning(push)
#pragma warning(disable: 4351)
#pragma warning(pop)
</pre>

* 밑에 처럼 하면 Test 경고는 출력이 안 되고, SubTest 경고는 출력된다.

<pre>
#pragma warning(push)
#pragma warning(disable: 4351)

class Test
{
    int m_ints[10];
    double m_doubles[10];

public:
    Test()
        : m_ints() // C4351
        , m_doubles() // C4351
    {
    }
};

#pragma warning(pop)

class SubTest : public Test
{
    bool bools[10];

public:
    SubTest()
        : bools() // C4351
    {
    }
};
</pre>

### CString <-> string

<pre>
string CStringToString(CString cstr)
{
	char cpResult[200];

#pragma warning(push)
#pragma warning(disable: 4996)
	strcpy(cpResult, CT2A(cstr));
	if (cpResult == NULL)
	{
		strcpy(cpResult, "");
	}
	cpResult[strlen(cpResult) + 1] = '\0';
#pragma warning(pop)

	return cpResult;
}

CString StringToCString(string str)
{
	CString strResult;

	strResult = str.c_str();
	strResult += '\0';

	return strResult;
}
</pre>


## 09.07

* MFC 인테리어 프로그램 개발

* mday 자기소개 발표!

* 이번 주 마무리
  * OpenSource 경진대회 휴가 계획 짜기
  * 밀렸던 자료 정리
  * 김남윤 교수님께 메일?
  * 다음 주 할 일 미리 정리


---

<br/>



## 09.10

* MFC 인테리어 프로그램 개발 시작

* 먼저 설계부터 하자. MVC 생각하면서 설계하면 좀 편함

* [단일 문서 기본 틀 생성](http://ryumin13.tistory.com/entry/mfc%EB%A1%9C-%ED%88%B4%EB%A7%8C%EB%93%A4%EA%B8%B0-%EA%B8%B0%EB%B3%B8-%EB%BC%88%EB%8C%80-%EB%A7%8C%EB%93%A4%EA%B8%B0?category=388236) : 진짜 어려움... FormView가 생성이 안 되서 따로 만들어 줘야 함, 만들어진 자료 확인

* MVC 패턴에 기반한 기본 틀 완성!




## 09.11

* [MFC InteriorProgram](https://github.com/wnsgml972/MFC-InteriorProgram) : 첫 커밋,   __Controller의 싱글톤과 FileManager, Main의 define__

* MVC 패턴에 기반한 기본 틀 함수 추가, MVC에 따른 패키징!

* DrawRoom, Select 구현

* SAFE DELETE, 원하는 뷰 포인터 얻어오기

<pre>
#define SAFE_DELETE(p) { if(p) {delete p; p = NULL;} }
</pre>

<pre>

☞ 헤더파일 포함 순서.
#include "stdafx.h"
#include "Example.h"
#include "MainFrm.h"
#include "ExampleDoc.h"
#include "ExampleView.h"

== SDI의 경우 ===

[ 뷰클래스의 포인터 받기 ]
1) SDI의 경우
CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
CTempView *pView = (CTempView *)pMainFrame->GetActiveView();


[정리하자면]
어플리케이션 클래스
1) CXXXXApp *pAPP = (CXXXXApp *)AfxGetApp();

메인플레임 클래스 얻기
1) CMainFrame *pMainFrame =(CMainFrame*) AfxGetApp()->m_pMainWnd;

View클래스 얻기
1) 메인플레임 클래스를 먼저 얻음.
2) CXXXXView *pView = (CXXXXView *)pMainFrame->GetActiveView();

Document 클래스 얻기
1) 메인플레임 클래스를 먼저 얻음.
2) CXXXXDoc *pDoc = (CXXXXDoc *)pMainFrame->GetActiveDocument();

[실제 프로그램 예시]
CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();  // 프레임 윈도우 포인터 구하고...
//CInteriorProgramView* pView = (CInteriorProgramView*)pFrame->GetActiveView(); // 활성화된 뷰의 포인터 구한다.
CInteriorProgramView* pView = (CInteriorProgramView*)pFrame->m_wndSplitter.GetPane(0, 0); // 활성화된 뷰의 포인터 구한다.

pView->RedrawWindow();
</pre>




## 09.12

* MFC 환경에서 console에 log 출력하는 법

<pre>
-> 이것을 stdafx.h의 제일 위에다 넣으면 됨

#ifdef _DEBUG
#ifdef UNICODE
#pragma comment(linker, "/entry:wWinMainCRTStartup /subsystem:console")
#else
#pragma comment(linker, "/entry:WinMainCRTStartup /subsystem:console")
#endif
#endif
</pre>

__

### 소멸자 virtual, c++의 instanceof인 typeid

- c++에서 virtual을 붙여주게 되면 상속 관계에서 파생 클래스의 함수를 부르게 된다.
- 상속 관계에서 소멸자에 virtual을 붙여놓지 않는다면, 만약 업캐스팅한 객체는 해당 가리키고 있는 객체의 소멸자를 호출하지 않게된다.
그러므로 통상적으로 상속관계에 있는 클래스중 제일 상위 클래스의 소멸자에는 보통 virtual을 붙인다.

- 여기에서 하나 문제가 있다. 해당 객체의 type을 알 수 있는 c++의 typeid에서, 업캐스팅한 객체의 타입을 알고 싶었는데
가리키고 있는 객체의 타입이 아닌 자기 자신만 가리키는 결과가 나왔다. <br/>
-> 해결방법으로 상위 클래스에 소멸자를 붙여주게 되면 하위 클래스의 소멸자를 호출하여 올바르게 가리키는 객체를 참조하는 결과가 나왔다. 그러므로 typeid를 쓰려면

<pre>
1. 헤더파일 typeinfo 선언
2. 상위 클래스의 소멸자에 virtual 선언
3. typeid(m_CaShape.at(i)) == typeid(DoorShape)
다음과 같이 비교하면 된다.
</pre>


### Select  (어려움...)

1. 알고리즘

2. 기준 꼭지점을 정해야함


### Move  (핵 어려움...)

1. MouseDown 시 선택된 Shape의 기준 꼭지점과 클릭한 point와의 차이점을 구해놓는다.

2. MouseMove에서 구해놓은 차이와 현재 드래그 되는 좌표값을 더해준다!

3. 그 값은 InteriorProgramView를 넘으면 안 된다.

4. 그 외 프로그램 상 각종 예외처리

### 진행상황

__[09.12] Issue 1. 80% 해결__

1. Move 성공!
2. Update 성공!
3. HowManySeleted 성공!
4. Current Selected 성공!
5. AddShape 미완
6. DeleteShape 미완

__현재까지 각종 Error 체크 했을 시 오류 없었음!__






## 09.13
