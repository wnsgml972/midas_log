# MIDAS LOG

## go home! [:house_with_garden:](https://github.com/wnsgml972/midas_log)

---

<br/><br/>

## 10.01

### C++ 문법 공부

#### 익명 함수 문법(Lambda)

<pre>
  auto bar = []() -> float { return 3.14f; }; // arrow function을 이용하면 타입 명시 가능
  [a,&b] a를 복사로 캡처, b를 참조로 캡처.
  [this] 현재 객체를 참조로 캡처.
  [&] 몸통에서 쓰이는 모든 변수나 상수를 참조로 캡처하고 현재 객체를 참조로 캡처.
  [=] 몸통에서 쓰이는 모든 변수나 상수를 복사로 캡처하고 현재 객체를 참조로 캡처.
  [] 아무것도 캡처하지 않음.  
</pre>

#### vector,  ```push_back vs emplace_back```


※ 실제 사용예
필자가 전에 push_back으로 작성했던 코드이다. 이 코드는 CStationObj 임시 객체를 생성하고 그것을 push_back에 전달하는 걸 알 수 있으며 성능을 따져봤을때 비효율적이다.(내부적으로 CStationObj의 임시 객체가 생성되고 생성자와 소멸자도 호출되기 때문)

<pre>
void CStationObj()
{
  m_vecStationObjs.push_back(CStationObj(3, 4));
}
</pre>

emplace_back은 함수 원형에서 본 거와 같이 가변 인자를 받을 수 있어서 아래와 같이 인자를 넣을 수 있으며, 받은 인자를 std::vector안에서 직접 CStationObj를 생성하므로 push_back보다 성능상 낫다.

<pre>
void CStationObj()
{
  m_vecStationObjs.push_back(3, 4);
}
</pre>

※ 참고 사항

- push_back으로 하여도 컴파일러 내부적으로 최적화 하기 때문에 emplace_back으로 하는 것과 별차이가 없을 수 있다. 고로 개인 프로젝트가 아니라면 호환성이 더 좋은 push_back 사용이 더 나을 수도 있다.
- push_back함수로 할 수 있는 모든 것을 emplace_back으로 할 수 있다.
- push_back함수보다 emplace_back 함수가 대체로 효율적이다.


### 해야 할 것

* Feature 툴 사용, 모델링 해보기 (4)
* mday ppt 제작
* shared_ptr 공부할 것

### 해결한 것

* Solid 기능 구현 약간


## 10.02

### 해결한 것

* MDay 발표 준비

### 해야 할 것

* Feature 툴 사용, 모델링 해보기 (4)
* mday ppt 제작
* shared_ptr 공부할 것
* Feature Solid




## 10.04

### 해결한 것

* Feature 툴 사용, 모델링 해보기 (4)

### 해야 할 것

* Feature 툴 사용, 모델링 해보기 (4)
* shared_ptr 공부할 것
* Feature Solid


## 10.05

### 해결한 것

* Feature Solid 하는 중

### 해야 할 것

* C++, C# ??
* shared_ptr 공부할 것
* Feature Solid
